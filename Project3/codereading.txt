1. When it exits we clean parts we dont need to run right away.  The rest has to wait until thread_destroy gets called.  When it sleeps we yield cpu to another process and go to sleep on "sleep address" ADD. Subsequent calls to thread_wakeip w/ same value of ADDR will make thread runnable again.  Interrupts must be off or you can sleep forever and you cannot sleep in an interrupt handler.
2. mi_switch(), md_switch()
3. There are 4 thread states: S_RUN, S_READY, S_SLEEP, S_ZOMB
4. Turning interrupts off means they are disabled. When it is off, an interrupt cannot be requested.  This is accomplished with the use of the splhigh function. In the thread.c file, s = splhigh() disbaled the interrupts for atomicity.  This is one of the reasons that it is important to turn the interrupt off so that it can run the thread subsystem atomically  w/o interrupts.  Also, as stated in question 1, if the interrupt is on when a thread is slept, it could end up sleeping forever.
5. When a thread is in a sleep state, the thread_wakeup() wakes it from the sleep state and makes it runnable again.  A sleeping thread gets to run again with subsequent calls to the thread_wakeup with the same value of ADDR (the "sleep address" ADDR) will make it runnable again.  Within the wakeup function, the sleeping thread is removed from the sleep list/queue and the function make_runnable is used to make it runnable again.
6. struct thread * scheduler(void): The actual scheduler. Returns the next thread to run.  Calls cpu_idle() if there nothing ready
7.This is also done by the scheduler(), it calls cpu_idle() recursively untill the runqueue is empty, if there are threads in the runque then the first thread in there is picked by scheduler()
8. The hardware timer is used in order to make periodic interrupts.  Within the hardclock.c file, the hardlock() function is called HZ times per second by the timer device setup.  The hardware independent fucntion that is called on the timer interrupt is the hardclock function.
9. These operations are used to control thread blocking/waking in semaphores. The channel argument identifies the condition the thread is waiting for and ensures synchronization.
10. The lock API in OS/161 provides lock_do_i_hold() in order to check if the thread calls holds the lock, It does not contain lock_get_holder() because the lock needs to be released by the thread that has the lock, so lock_get_holder() would not be useful.
